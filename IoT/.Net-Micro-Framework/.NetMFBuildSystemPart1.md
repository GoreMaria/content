Как объять необъятное: система сборки .NET Micro Framework Часть 1.

![enter image description here](https://habrastorage.org/files/147/683/616/1476836161574ab6a8d5129088e89c85.png)

Большинство разработчиков давно привыкли использовать ту или иную [IDE](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D1%80%D0%B5%D0%B4%D0%B0_%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8) и не задумываются о том, а как, собственно, их исходный код превращается в исполняемый модуль. Современные средства разработки содержат [UI](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F) и автоматизацию сборки для огромного числа типов проектов на все случаи жизни. И это очень здорово, так как позволят не задумываться над вещами, которые не имеют непосредственного отношения к задаче, решаемой программой. Но иногда задача бывает настолько сложной, что уже не получается использовать стандартные типы проектов. И тут на поверхность всплывает "Система сборки проектов". 

Ярким примером такого типа проектов является [.NET Micro Framework](https://ru.wikipedia.org/wiki/.NET_Micro_Framework) - реализация платформы Microsoft .NET для микроконтроллеров. В этой статье я расскажу том, как устроены его [репозиторий](https://github.com/NETMF/netmf-interpreter) и система сборки.


----------

##Постановка задачи##

Прежде чем говорить о том, как устроен проект и как происходит его сборка, нужно понять какие перед проектом стоят цели и какие из этого следуют требования.

Идея .Net Micro Framewok заключается в том, чтобы разрабатывать приложения на .Net для самых маленьких устройств, управляемых микроконтроллерами. Такие устройства обладают несколькими сотнями килобайт Flash памяти и несколькими десятками килобайт RAM. Из-за ограниченности ресурсов на них нельзя использовать полноценные операционные системы, включая их IoT редакции.

Обычно разработка для таких устройств ведется на C\C++ со вставками на ассемблере и тесно связана с конкретным микроконтроллером, так как все управление "железом" происходит через запись и чтение множества регистров. При этом используются компиляторы и линковщики из специализированного набора для платформы - [Toolchain](https://en.wikipedia.org/wiki/Toolchain).

> Раньше на рынке было множество разных [архитектур
> микроконтроллеров](https://ru.wikipedia.org/wiki/%D0%9C%D0%B8%D0%BA%D1%80%D0%BE%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80).
> Каждый производитель имел несколько семейств устройств и для каждого
> семейства могла быть своя схема регистров. Кроме того, было множество
> разных toolchain. По этому выбор микроконтроллера был крайне важной
> вехой проекта, так как потом перейти на другое устройство было очень и
> очень сложно.
> 
> Сейчас миром микроконтроллеров правит
> [ARM](https://ru.wikipedia.org/wiki/ARM_%28%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0%29).
> Многие производители отказались от собственных ядер и перешли на эту
> архитектуру. Это позволило сильно унифицировать разработку и облегчить
> миграцию с одного устройства на другое. Кроме того, огромными темпами
> развивается
> [CMSIS](http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php)
> - наборт стандартных программных интерфейсов для работы с ARM микроконтроллерами, не зависящий от конкретного производителя.
> Каждый производитель поставляет реализацию CMSIS для своих устройств, что позволяет, теоретически, абстрагироваться от особенностей реализации того или иного микроконтроллера.
>
>Но, тем не мене, на рынке еще существует достаточно большое количество устройств как с отличной от ARM архитектурой, так и не имеющих реализации CMSIS.

.Net Micro Framework - это попытка поднять разработку для микроконтроллеров на более высокий уровень абстракции. Если CMSIS унифицирует устройства с ARM архитектурой, то .NetMF пытается унифицировать работу с микроконтроллерами в принципе. И, заодно, позволяет использовать мощь управляемого кода и удобство Visual Studio при разработке для встраиваемых систем. При этом никто не ограничивает использование .NetMF только микроконтроллерами. Существует его реализация для Windows, которая используется в [эмуляторе](https://geektimes.ru/post/265986/).

Таким образом, основным требованием к .NetMF является возможность запуска на любом микроконтроллере имеющем достаточное количество памяти (в документации указаны минимальные требования 256KB RAM и 512K Flash/ROM). Исходя из этого, компиляция должна происходить разными toolchain, в зависимости от выбранного устройства. Архитектура системы должна учитывать то, что работа на низком уровне, с "железом" может вестись как по средствам одной из реализаций CMSIS, так и любой другой библиотеки или операционной системы( как в случае эмулятора для Windows).

Другие требования, связанные с реализацией .Net, системы безопасности, отладки и тд. я не буду рассматривать, так как они не имеют влияния на систему сборки проекта.

##Архитектура решения##

Итак, к системе предявляются три основных требования:

1. Возможность запуска на любом микроконтроллере, обладающем необходимым объемом памяти.
2. Возможность использовать разные toolchain.
3. Возможность использования как API операционной системы, так и широкий набор библиотек для работы с "железом".

Причем пункт 2 и 3 являются следствием первого пункта.

.Net Micro Framework имеет следующую архитектуру:

![enter image description here](https://habrastorage.org/storage/fdd6d69f/11f7e201/37802566/9f6ae01e.jpg)

Система разделена на несколько слоев:

Два верхних слоя (приложения пользователя и системные библиотеки) написаны на управляем коде. Это то, что мы видим в Visual Studio. Слой аппаратного обеспечения — это и есть само «железо» на котором запущен .NetMF. Ну а слой TinyCLR — это среда исполнения кода. 

TinyCLR разделена на 3 части:

1. CLR — тут все, что касается исполнения управляемого кода, типизации, сборки мусора и т.д.
2. PAL (Platform Abstraction Layer) — Классы и функции для работы с общими абстракциями, такими как счетчики, таймеры, ввод-вывод. Эти классы одинаковы для всех аппаратных платформ.
3. HAL (Hardware Abstraction Layer) — Классы и функции дня работы непосредственно с «железом».

Разделение на PAL и HAL позволяет требование номер три (Возможность использования как API операционной системы, так и широкий набор библиотек для работы с "железом").

Абстракция HAL представляет собой набор интерфейсов с которыми работает PAL и более высокие уровни. Это позволяет делать множество реализаций для разных платформ и использовать любые библиотеки или API в этих реализациях.

Таким образом, разработчики разделяют код на следующие слои:

![enter image description here](https://github.com/NETMF/netmf-interpreter/wiki/images/NetMFLayerDiagram.png)

Часть, обозначенная на схеме как Native Code написана на C/C++. Managed code написан на C#. Соответственно, разные части репозитория компилируются разными компиляторами. 

Чтобы реализовать возможность компиляции разными toolchain, при этом сохранить целостность проекта, нужна мощная система сборки проектов, которая позволяет производить гибкую настройку всего процесса. Система сборки первых версий .NetMF была основана на [MAKEFILE](https://habrahabr.ru/post/155201/) . Затем произошел переход на [MSBuild](https://ru.wikipedia.org/wiki/MSBuild). Причем, на тот момент, сборка Visual C++ проектов в Visual Studio не использовала MSBuild (а большая часть NetMF написана на C\C++), по этому пришлось делать "нестандартные" проект. Результат получился копией системы сборки, основанной на MAKEFILE, так как это было сделать быстрее и проще всего.

В итоге, все это позволило реализовать все требования, связанные с мультиплатформенностью .NetMF.

##Особенности реализации##

Недавно была опубликована [статья](https://github.com/NETMF/netmf-interpreter/wiki/BuildSystemRequirements) о системе сборки .NetMF. Автор описывает проблемы, которые приходится решать при сборке проекта.

Имеется несколько сценариев работы:

1. Сборка компонентов, необходимых для построения остальной части репозитория. А именно, любых расширений, которые требуются для сборки, но не входят в стандартный набор системы сборки проектов.
2. Сборка и настройка утилит, необходимых для сборки проекта. Этот пункт важно отличить от предыдущего. Если в первом пункте собирались именно расширения системы сборки (например, расширения для MSBuild) то в этом пункте собираются именно дополнительные утилиты. Например утилита, делающая цифровые подписи.
3. Сборка SDK, которая будет использоваться разработчиками при создании приложения для .NetMF в Visual Studio. Сюда входят VSIX палагин и необходимые библиотеки, включаемые в проект.
4. Сборка "портов" для аппаратного обеспечения. То есть сборка TinyCLR для конкретной платы.
5. Сборка сторонних приложений для .NetMF. Система сборки должна быть автономной уметь собирать .NetMF приложения и без использования Visual Studio.

.Net Micro Framework является "архитектурно нейтральной" включая как как big-endian так и little-endian системы. 















Таким образом получается, что при сборке, должны учитываться, как минимум, следующие особенности:

1. Использование разных наборов средств компиляции([Toolchain](https://en.wikipedia.org/wiki/Toolchain)) для разных платформ и процессоров при компиляции Native code
2.  Сборка как для [big-endian так и для little-endian систем](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA_%D0%B1%D0%B0%D0%B9%D1%82%D0%BE%D0%B2)
3. Использование C# компилятора для сборки Managed code
4.  Разные реализации HAL для разных платформ
5. Возмоность использования OS API вместо или вместе с PAL


Кроме того, в процессе сборки участвует набор как сторонних утилит, так и написанных специально для .NetMF. Причем эти утилиты так же должны быть собраны перед тем, как будет произведена сборка основной части репозитория.

А еще, репозиторий включает в себя исходники для интеграции с VisualStudio.

Подводя итог, можно выделить несколько сценариев, которые должны быть выполнены системой сборки проекта .NetMF:

1. Сборка компонентов, необходимых для построения остальной части репозитория. А именно, любых расширений, которые требуются для сборки, но не входят в стандартный набор системы сборки проектов.
2. Сборка и настройка утилит, необходимых для сборки проекта. Этот пункт важно отличить от предыдущего. Если в первом пункте собирались именно расширения системы сборки (например, расширения для MSBuild) то в этом пункте собираются именно дополнительные утилиты. Например утилита, делающая цифровые подписи.
3. Сборка SDK, которая будет использоваться разработчиками при создании приложения для .NetMF в Visual Studio. Сюда входят VSIX палагин и необходимые библиотеки, включаемые в проект.
4. Сборка "портов" для аппаратного обеспечения. То есть сборка TinyCLR для конкретной платы.
5. Сборка сторонних приложений для .NetMF. Система сборки должна быть автономной уметь собирать .NetMF приложения и без использования Visual Studio.

Первые два пункта являются обязательными для выполнения третьего, четвертого и пятого, но ,как правило, могут быть выполнены всего один раз.

Третий пункт, тоже выполняется редко, так как изменения в SDK происходят в основном только при переходе к новым релизам .NetMF.

Сборка SDK включает в себя следующие шаги:

1. Сборка предварительных частей. Этот этап включает в себя 1 и 2 пункты из списка выше
2. Коспиляция исходного кода в DLL
3. Преобразования DLL в PE файлы содержащие отладочную информацию как для big-endian так и для little-endian систем.
4. Сборка компонентов для интеграции с Visual Studio.
5. Подписывание всех компонентов перед упаковкой в пакеты
6. Сборка VSIX пакетов для поддерживающихся версий Visual Studio
7. Подписывание VSIX пакетов
8. Сборка SDK MSI пакетов
9. Подписывание SDK MSI пакетов

Сборка сторонних приложений для .NetMF по сути повторяет то же, что делает Visual Studio, но без использования IDE.

Наиболее интересным и важным является четвертый пункт - сборка "портов". О нем мы поговорим немного позже. А сейчас стоит отметить, что есть одна очень важная особенность, касающаяся любых проектов - разрешение зависимостей.

##Разрешение зависимостей##

Любой проект так или иначе сталкивается со ссылками между его составными частями. Это могут быть как ссылки между файлами, так и ссылки между программными модулями, такими как .exe и .dll. В общем случае существует два типа зависимостей, которые нужно разрешать:

1. *Жесткие зависимости*.
Этот тип зависимостей появляется, одна часть программы явно зависит от другой. Например, приложение A использует библиотеку xyz. Такие зависимости легко могут быть автоматически разрешены. В этом случае системе сборки понятно, что сначала нужно собрать библиотеку xyz, а потом уже приложение A. В более современных системах сборки, xyz и A могут собираться параллельно в разных потоках, но линковка все равно будет происходить после того, как будут собраны все компоненты.
2. *Мягкие зависимости*.
Этот тип зависимостей возникает, когда одна часть программы ссылается на интерфейс или API, которые могут иметь множество равнозначных реализаций. В этом случае, система сборки не может автоматически определить, какую из реализаций ей использовать. Если существует только одна реализация, то система сборки сможет определить, что ей использовать. Если реализаций несколько, то ей нужно явно тем или иным способом указать, что ей нужно брать.
